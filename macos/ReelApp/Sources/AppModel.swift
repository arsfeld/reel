import Foundation

// The swift-bridge generated Swift files must be copied into
// macos/ReelApp/Generated and included in the target. Those files define
// types like MacOSCore, BackendBridge, EventSub, and free fn get_build_info().

@MainActor
final class AppModel: ObservableObject {
    @Published var buildInfo: String = ""
    @Published var initialized: Bool = false
    @Published var backends: [BackendBridge] = []

    private var core: MacOSCore? = nil
    private var eventSub: EventSub? = nil

    func startup() {
        guard core == nil else { return }

        // Generated by swift-bridge (from Rust function get_build_info())
        self.buildInfo = get_build_info()

        // Construct and initialize core
        var c = make_core()
        if c.sb_initialize() {
            self.core = c
            self.initialized = true
            self.refreshBackends()
            self.subscribeToEvents()
        } else {
            self.initialized = false
        }
    }

    func refreshBackends() {
        guard let c = core else { return }
        self.backends = c.list_backends()
    }

    func subscribeToEvents() {
        guard let c = core else { return }
        let sub = c.subscribe(["media.created", "media.updated", "sync.completed"]) 
        self.eventSub = sub
        listenForEvents()
    }

    func listenForEvents() {
        guard let sub = eventSub else { return }
        Task.detached(priority: .background) { [weak self] in
            var mutableSub = sub
            while true {
                if let evt = mutableSub.next_event_blocking(250) {
                    await self?.handle(event: evt)
                }
            }
        }
    }

    func handle(event: EventBridge) {
        // For now, just refresh backends on sync completion
        if event.kind == "sync.completed" {
            refreshBackends()
        }
    }
}

